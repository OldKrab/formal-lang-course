from typing import Any, Set, Tuple, Union
from pyformlang.cfg import CFG, Terminal, Variable
import networkx as nx

from project.context_free_grammar import convert_cfg_to_wcnf, read_cfg_from_file


def _helling_algorithm_for_wcnf(
    graph: nx.MultiDiGraph, cfg: CFG
) -> Set[Tuple[Any, Variable, Any]]:
    def is_epsilon_prod(prod):
        return len(prod.body) == 0

    def is_terminal_prod(prod, terminal):
        return len(prod.body) == 1 and terminal in prod.body

    def get_init_r():
        return {
            (v, prod.head, v)
            for v in graph.nodes
            for prod in cfg.productions
            if is_epsilon_prod(prod)
        } | {
            (v, prod.head, u)
            for v, u, t in graph.edges(data="label")
            for prod in cfg.productions
            if is_terminal_prod(prod, Terminal(t))
        }

    r = get_init_r()
    queue = r.copy()
    while len(queue) > 0:
        v, N_i, u = queue.pop()
        r_diff = set()
        for v_2, N_j, u_2 in r:
            if u_2 == v:
                for prod in cfg.productions:
                    if prod.body == [N_j, N_i]:
                        queue.add((v_2, prod.head, u))
                        r_diff.add((v_2, prod.head, u))

        for v_2, N_j, u_2 in r:
            if v_2 == u:
                for prod in cfg.productions:
                    if prod.body == [N_i, N_j]:
                        queue.add((v, prod.head, u_2))
                        r_diff.add((v, prod.head, u_2))
        r = r | r_diff
    return r


def _helling_all_start_and_final(
    graph: Union[nx.MultiDiGraph, str], cfg: Union[CFG, str]
):
    if isinstance(cfg, str):
        cfg = read_cfg_from_file(cfg)
    if isinstance(graph, str):
        graph: nx.MultiDiGraph = nx.nx_pydot.from_pydot(graph)
    return _helling_algorithm_for_wcnf(graph, convert_cfg_to_wcnf(cfg))


def helling(
    graph: Union[nx.MultiDiGraph, str],
    cfg: Union[CFG, str],
    start_nodes: Union[Set[Any], None] = None,
    final_nodes: Union[Set[Any], None] = None,
    variable: Union[Variable, None] = None,
):
    """
    Applies the Helling algorithm to a given CFG and graph to find all paths in the graph
    that correspond to a string generated by the CFG.

    Args:
        graph: The graph to traverse.
        cfg: The CFG. It can be a `CFG` object or a string path to a file containing the CFG.
        start_nodes: A set of start nodes in the graph. If not provided, all nodes are considered start nodes.
        final_nodes: A set of final nodes in the graph. If not provided, all nodes are considered final nodes.
        variable: The variable to use for generating strings. If not provided, all variables are used.

    Returns:
        A set of tuples representing paths in the graph that correspond to a string generated
        by the CFG. Each tuple has the form (v, N, u), where v and u are nodes in the graph, and
        N is a variable in the CFG.
    """

    result = _helling_all_start_and_final(graph, cfg)

    start_pred = final_pred = var_pred = lambda _: True
    if start_nodes is not None:
        start_pred = lambda node: node in start_nodes
    if final_nodes is not None:
        final_pred = lambda node: node in final_nodes
    if variable is not None:
        var_pred = lambda v: v == variable

    return {
        (v, N, u)
        for v, N, u in result
        if start_pred(v) and var_pred(N) and final_pred(u)
    }
